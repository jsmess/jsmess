/***************************************************************************

        Irisha machine driver by Miodrag Milanovic

        27/03/2008 Preliminary driver.

****************************************************************************/


#include "driver.h"
#include "cpu/i8085/i8085.h"
#include "devices/cassette.h"
#include "machine/8255ppi.h"
#include "machine/pit8253.h"
#include "machine/pic8259.h"
#include "machine/msm8251.h"

static int irisha_keyboard_mask;

/* Driver initialization */
DRIVER_INIT(irisha)
{
	irisha_keyboard_mask = 0;
	/* set initialy ROM to be visible on first bank */
/*  UINT8 *RAM = memory_region(REGION_CPU1);
    memset(RAM,0x0000,0x0800); // make frist page empty by default
  memory_configure_bank(1, 1, 2, RAM, 0x0000);
    memory_configure_bank(1, 0, 2, RAM, 0xf800);    */
}

/*READ8_HANDLER (irisha_8255_portb_r )
{
    return readinputport(irisha_keyboard_line);
}

READ8_HANDLER (irisha_8255_portc_r )
{
    return readinputport(8);
}

WRITE8_HANDLER (irisha_8255_porta_w )
{
    switch (data ^ 0xff) {
        case 0x01 : irisha_keyboard_line = 0;break;
        case 0x02 : irisha_keyboard_line = 1;break;
        case 0x04 : irisha_keyboard_line = 2;break;
        case 0x08 : irisha_keyboard_line = 3;break;
        case 0x10 : irisha_keyboard_line = 4;break;
        case 0x20 : irisha_keyboard_line = 5;break;
        case 0x40 : irisha_keyboard_line = 6;break;
        case 0x80 : irisha_keyboard_line = 7;break;
    }
}

static const ppi8255_interface irisha_ppi8255_interface =
{
    1,
    {NULL},
    {irisha_8255_portb_r},
    {irisha_8255_portc_r},
    {irisha_8255_porta_w},
    {NULL},
    {NULL},
};

static TIMER_CALLBACK( irisha_reset )
{
    memory_set_bank(1, 0);
}

MACHINE_RESET( irisha )
{
    timer_set(ATTOTIME_IN_USEC(10), NULL, 0, irisha_reset);
    memory_set_bank(1, 1);
    ppi8255_init(&irisha_ppi8255_interface);
    irisha_keyboard_line = 0;
}


READ8_HANDLER( irisha_keyboard_r )
{
    return ppi8255_0_r(machine, offset^0x03);
}

WRITE8_HANDLER( irisha_keyboard_w )
{
    ppi8255_0_w(machine, offset^0x03, data);
}


WRITE8_HANDLER( irisha_tape_w )
{
    cassette_output(image_from_devtype_and_index(IO_CASSETTE, 0),data & 0x01 ? 1 : -1);
}


READ8_HANDLER( irisha_tape_r )
{
    double level = cassette_input(image_from_devtype_and_index(IO_CASSETTE, 0));
    if (level <  0) {
            return 0x00;
    }
    return 0xff;
}
static UINT8 irisha_keyboard_rom[] = {
 0x81 ,0x85 ,0x2B ,0x31 ,0x32 ,0x33 ,0x34 ,0x35 ,0x38 ,0x37 ,0x38 ,0x39 ,0x30 ,0x3D ,0x09 ,0x08,
 0x82 ,0x1B ,0x0A ,0x03 ,0x15 ,0x0B ,0x05 ,0x0E ,0x07 ,0x1B ,0x1D ,0x1A ,0x08 ,0x2A ,0x0D ,0x0A,
 0x83 ,0x18 ,0x08 ,0x19 ,0x17 ,0x01 ,0x10 ,0x12 ,0x0F ,0x0C ,0x04 ,0x16 ,0x1C ,0x3E ,0x1A ,0x1C,
 0x84 ,0x20 ,0x11 ,0x1E ,0x13 ,0x0D ,0x09 ,0x14 ,0x18 ,0x02 ,0x00 ,0x3C ,0x3F ,0x7F ,0x1D ,0x19,
 0x81 ,0x85 ,0x2B ,0x21 ,0x22 ,0x23 ,0x24 ,0x25 ,0x26 ,0x27 ,0x28 ,0x29 ,0x30 ,0x3D ,0x09 ,0x08,
 0x82 ,0x1B ,0x5A ,0x63 ,0x75 ,0x6B ,0x65 ,0x6E ,0x67 ,0x7B ,0x7D ,0x7A ,0x68 ,0x2A ,0x0D ,0x0A,
 0x83 ,0x18 ,0x66 ,0x79 ,0x77 ,0x81 ,0x70 ,0x72 ,0x8F ,0x6C ,0x64 ,0x76 ,0x7C ,0x3E ,0x1A ,0x1C,
 0x84 ,0x20 ,0x71 ,0x7E ,0x73 ,0x6D ,0x69 ,0x74 ,0x78 ,0x82 ,0x80 ,0x3C ,0x3F ,0x5F ,0x1D ,0x19,
 0x81 ,0x85 ,0x3B ,0x31 ,0x32 ,0x33 ,0x34 ,0x35 ,0x36 ,0x37 ,0x38 ,0x39 ,0x30 ,0x2D ,0x09 ,0x08,
 0x82 ,0x1B ,0x0A ,0x03 ,0x15 ,0x0B ,0x05 ,0x0E ,0x07 ,0x1B ,0x1D ,0x1A ,0x08 ,0x3A ,0x0D ,0x0A,
 0x83 ,0x18 ,0x06 ,0x19 ,0x17 ,0x01 ,0x10 ,0x12 ,0x0F ,0x0C ,0x04 ,0x16 ,0x1C ,0x2E ,0x1A ,0x1C,
 0x84 ,0x20 ,0x11 ,0x1E ,0x13 ,0x0D ,0x09 ,0x14 ,0x18 ,0x02 ,0x00 ,0x2C ,0x2F ,0x7F ,0x1D ,0x19,
 0x81 ,0x85 ,0x3B ,0x31 ,0x32 ,0x33 ,0x34 ,0x35 ,0x36 ,0x37 ,0x38 ,0x39 ,0x30 ,0x2D ,0x09 ,0x08,
 0x82 ,0x1B ,0x4A ,0x43 ,0x55 ,0x4B ,0x45 ,0x4E ,0x47 ,0x5B ,0x5D ,0x5A ,0x48 ,0x3A ,0x0D ,0x0A,
 0x83 ,0x18 ,0x46 ,0x59 ,0x57 ,0x41 ,0x50 ,0x52 ,0x4F ,0x4C ,0x44 ,0x56 ,0x5C ,0x2E ,0x1A ,0x1C,
 0x84 ,0x20 ,0x51 ,0x5E ,0x53 ,0x4D ,0x49 ,0x54 ,0x58 ,0x42 ,0x40 ,0x2C ,0x2F ,0x7F ,0x1D ,0x19,
 0x81 ,0x85 ,0x2B ,0x31 ,0x32 ,0x33 ,0x34 ,0x35 ,0x36 ,0x37 ,0x38 ,0x39 ,0x30 ,0x3D ,0x09 ,0x08,
 0x82 ,0x1B ,0x0A ,0x03 ,0x15 ,0x0B ,0x05 ,0x0E ,0x07 ,0x1B ,0x1D ,0x1A ,0x08 ,0x2A ,0x0D ,0x0A,
 0x83 ,0x18 ,0x08 ,0x19 ,0x17 ,0x01 ,0x10 ,0x12 ,0x0F ,0x0C ,0x04 ,0x16 ,0x1C ,0x3E ,0x1A ,0x1C,
 0x84 ,0x20 ,0x11 ,0x1E ,0x13 ,0x0D ,0x09 ,0x14 ,0x18 ,0x02 ,0x00 ,0x3C ,0x3F ,0x7F ,0x1D ,0x19,
 0x81 ,0x85 ,0x2B ,0x21 ,0x22 ,0x23 ,0x24 ,0x25 ,0x26 ,0x27 ,0x28 ,0x29 ,0x30 ,0x3D ,0x09 ,0x08,
 0x82 ,0x1B ,0xCA ,0xC3 ,0xD5 ,0xCB ,0xC5 ,0xCE ,0xC7 ,0xDB ,0xDD ,0xDA ,0xC8 ,0x2A ,0x0D ,0x0A,
 0x83 ,0x18 ,0xC8 ,0xD9 ,0xD7 ,0xC1 ,0xD0 ,0xD2 ,0xCF ,0xCC ,0xC4 ,0xD8 ,0xDC ,0x3E ,0x1A ,0x1C,
 0x84 ,0x20 ,0xD1 ,0xDE ,0xD3 ,0xCD ,0xC9 ,0xD4 ,0xD8 ,0xC2 ,0xC0 ,0x3C ,0x3F ,0x5F ,0x1D ,0x19,
 0x81 ,0x85 ,0x3B ,0x31 ,0x32 ,0x33 ,0x34 ,0x35 ,0x36 ,0x37 ,0x38 ,0x39 ,0x30 ,0x2D ,0x09 ,0x08,
 0x82 ,0x1B ,0x0A ,0x03 ,0x15 ,0x0B ,0x05 ,0x0E ,0x07 ,0x1B ,0x1D ,0x1A ,0x08 ,0x3A ,0x0D ,0x0A,
 0x83 ,0x18 ,0x08 ,0x19 ,0x17 ,0x01 ,0x10 ,0x12 ,0x0F ,0x0C ,0x04 ,0x16 ,0x1C ,0x2E ,0x1A ,0x1C,
 0x84 ,0x20 ,0x11 ,0x1E ,0x13 ,0x0D ,0x09 ,0x14 ,0x18 ,0x02 ,0x00 ,0x2C ,0x2F ,0x7F ,0x1D ,0x19,
 0x81 ,0x85 ,0x3B ,0x31 ,0x32 ,0x33 ,0x34 ,0x35 ,0x36 ,0x37 ,0x36 ,0x39 ,0x30 ,0x2D ,0x09 ,0x06,
 0x82 ,0x1B ,0xEA ,0xE3 ,0xF5 ,0xEB ,0xE5 ,0xEE ,0xE7 ,0xFB ,0xFD ,0xFA ,0xE8 ,0x3A ,0x0D ,0x0A,
 0x83 ,0x18 ,0xE6 ,0xF9 ,0xF7 ,0xE1 ,0xF0 ,0xF2 ,0xEF ,0xEC ,0xE4 ,0xF8 ,0xFC ,0x2E ,0x1A ,0x1C,
 0x84 ,0x20 ,0xF1 ,0xFE ,0xF3 ,0xED ,0xE9 ,0xF4 ,0xF8 ,0xE2 ,0xE0 ,0x2C ,0x2F ,0xDF ,0x1D ,0x19 };

*/

static UINT8 irisha_keypressed;
UINT8 irisha_keyboard_cnt = 0;

static TIMER_CALLBACK( irisha_key )
{
	irisha_keypressed = 1;
	irisha_keyboard_cnt = 0;
}


MACHINE_RESET( irisha )
{
	timer_pulse(ATTOTIME_IN_MSEC(30), NULL, 0, irisha_key);
  irisha_keypressed = 0;
}

/*
READ8_HANDLER (irisha_8255_portb_r )
{
    int i;
    UINT8 keycode;
        static const char *keynames[] = {
                            "LINE0", "LINE1", "LINE2", "LINE3",
                            "LINE4", "LINE5", "LINE6", "LINE7",
                            "LINE8", "LINE9", "LINE10","LINE11",
                            "LINE12","LINE13","LINE14","LINE15" };

    for(i = 0; i < 16; i++)
    {

        keycode = input_port_read(machine, keynames[i]);
      if (keycode!=0) {
        switch(keycode) {
            case 1 : irisha_keycode = irisha_keyboard_rom[i + (0 * 16) + 0xC0];break;
            case 2 : irisha_keycode = irisha_keyboard_rom[i + (1 * 16) + 0xC0];break;
            case 4 : irisha_keycode = irisha_keyboard_rom[i + (2 * 16) + 0xC0];break;
            case 8 : irisha_keycode = irisha_keyboard_rom[i + (3 * 16) + 0xC0];break;
        }
        logerror("irisha_keycode = [%02x][%c] \n",irisha_keycode,irisha_keycode);
        irisha_keycode ^= 0xff;
        return 0x80;
      }
  }
    return 0x00;
}
*/
static const char *keynames[] = {
							"LINE0", "LINE1", "LINE2", "LINE3",
							"LINE4", "LINE5", "LINE6", "LINE7",
							"LINE8", "LINE9"};

READ8_HANDLER (irisha_8255_portb_r )
{
  if (irisha_keypressed==1) {
  	irisha_keypressed =0;
  	return 0x80;
  }

	return 0x00;
}

READ8_HANDLER (irisha_8255_portc_r )
{
	logerror("irisha_8255_portc_r\n");
	return 0;
}

READ8_HANDLER (irisha_keyboard_r)
{
	UINT8 keycode;
 	if (irisha_keyboard_cnt!=0 && irisha_keyboard_cnt<11) {
		keycode = input_port_read(machine, keynames[irisha_keyboard_cnt-1]) ^ 0xff;
	} else {
		keycode = 0xff;
	}
	irisha_keyboard_cnt++;
	return keycode;
}

WRITE8_HANDLER (irisha_8255_porta_w )
{
	logerror("irisha_8255_porta_w %02x\n",data);
}

WRITE8_HANDLER (irisha_8255_portb_w )
{
	logerror("irisha_8255_portb_w %02x\n",data);
}

WRITE8_HANDLER (irisha_8255_portc_w )
{
	//logerror("irisha_8255_portc_w %02x\n",data);
}

const ppi8255_interface irisha_ppi8255_interface =
{
	NULL,
	irisha_8255_portb_r,
	irisha_8255_portc_r,
	irisha_8255_porta_w,
	irisha_8255_portb_w,
	irisha_8255_portc_w,
};

static PIC8259_SET_INT_LINE( irisha_pic_set_int_line )
{
	cpunum_set_input_line(device->machine, 0, 0,interrupt ?  HOLD_LINE : CLEAR_LINE);
}

const struct pic8259_interface irisha_pic8259_config = {
	irisha_pic_set_int_line
};

const struct pit8253_config irisha_pit8253_intf =
{
	{
		{
			0,
			NULL
		},
		{
			0,
			NULL
		},
		{
			2000000,
			NULL
		}
	}
};


