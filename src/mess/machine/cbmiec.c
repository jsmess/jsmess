/**********************************************************************

    Commodore IEC Serial Bus emulation

    Copyright MESS Team.
    Visit http://mamedev.org for licensing and usage restrictions.

**********************************************************************/

/*

C64 SERIAL BUS


 Serial Bus Pinouts


    Pin Name    Description
     1  SRQ     Serial Service Request In
     2  GND     Ground
     3  ATN     Serial Attention In/Out
     4  CLK     Serial Clock In/Out
     5  DATA    Serial Data In/Out
     6  RESET   Serial Reset

    All signals are active low.


  SRQ: Serial Service Request In

 This signal is not used on the C64. On C128 it is replaced with Fast Serial
 Clock for the 1571 disk drive.


  ATN: Serial Attention In/Out

 Sending any byte with the ATN line low (sending under attention) causes it
 to be interpreted as a Bus Command for peripherals on the serial bus.

 When the C64 brings this signal LOW, all other devices start listening for
 it to transmit an address. The device addressed must respond in a preset
 period of time; otherwise, the C64 will assume that the device addressed is
 not on the bus, and will return an error in the STATUS word.

 Usually, the address byte will be followed by one to two commands for the
 device addressed, meaning the secondary address and channel on the peripheral.
 Such a command can be one of the following:

    20
    40
    60
    E0
    F0


  CLK: Serial Clock In/Out

  This signal is for timing the data sent on the serial bus. This signal is
  always generated by the active TALKER. RISING EDGE OF THE CLOCK means data
  bit is valid.


  DATA: Serial Data In/Out

  Data on the serial bus is transmitted bit by bit at a time on this line.


  RESET: Serial Reset

  You may disconnect this line to save your disk drive. The easiest way is to
  do that on the cable, thus avoiding any modifications on your peripherals.



  Serial Bus Timing

 ___
 CLK    |____|~~~~| Ts Bit Set-up time
    : Ts : Tv : Tv Bit Valid time



     |<--------- Byte sent under attention (to devices) ------------>|

 ___    ____                                                        _____ _____
 ATN       |________________________________________________________|
       :                                :
 ___    ______     ________ ___ ___ ___ ___ ___ ___ ___ ___         :
 CLK       : |_____|      |_| |_| |_| |_| |_| |_| |_| |_| |______________ _____
       :       :        :                 :         :
       : Tat : :Th: Tne :                             : Tf : Tr :
 ____   ________ : :  :___________________________________:____:
 DATA   ___|\\\\\\\\\\__:__|    |__||__||__||__||__||__||__||__|    |_________ _____
                  :     0   1   2   3   4   5   6   7      :
                  :    LSB                         MSB     :
              :     :                      :
              :     : Data Valid      Listener: Data Accepted
              : Listener READY-FOR-DATA




        END-OR-IDENTIFY HANDSHAKE (LAST BYTE IN MESSAGE)
 ___    _______________________________________________________________________
 ATN
 ___     ___ ___      ________________ ___ ___ ___ ___ ___ ___ ___ ___       __
 CLK    _| |_| |______|              |_| |_| |_| |_| |_| |_| |_| |_| |_______|_
           :      :          :                               :       :
           :Tf:Tbb:Th:Tye:Tei:Try:                               :Tf :Tfr:
 ____   __________:   :  :___:   :_______________________________________:   :_
 DATA   |__||__|  |______|   |___|   :                                   |___|_
     6   7        :  :   :   :   :                   :
        MSB       :  :   :   :   : Talker Sending            :
              :  :   :   : Listener READY-FOR-DATA      System
              :  :   : EOI-Timeout Handshake          Line Release
              :  : Listener READY-FOR-DATA
              : Talker Ready-To-Send




        TALK-ATTENTION TURN AROUND (TALKER AND LISTENER REVERSED)
 ___                 _________________________________________________________
 ATN    _____________|
             :
 ___     ___ ___     :   _____   ________ ___ ___ ___ ___ ___ ___ ___ ___
 CLK    _| |_| |_________|   |___|      |_| |_| |_| |_| |_| |_| |_| |_| |_____
           :     :   :   :   :      :                               :
           :Tf:Tr:Ttk:Tdc:Tda:Th:Try:                               :Tf :
 ____   __________:  :       :   :  :_______________________________________:
 DATA   |__||__|  |_________________|   :|__||__||__||__||__||__||__||__|   |_
     6   7       :   :   :   :  :   : 0   1   2   3   4   5   6   7
        MSB      :   :   :   :  :   :LSB                         MSB
             :   :   :   :  :   :
             :   :   :   :  :   : Data Valid
             :   :   :   :  : Listener READY-FOR-DATA
             :   :   :   : Talker Ready-To-Send
             :   :   : Device acknowledges it's now TALKER.
             :   : Becomes LISTENER, Clock = High, Data = Low
             : Talker Ready-To-Send




 ___    _____________________________________________________________________
 ATN
 ___        _________ ___ ___ ___ ___ ___ ___ ___ ___       ________ ___ ___
 CLK    ____|       |_| |_| |_| |_| |_| |_| |_| |_| |_______|      |_| |_| |_
        :       :                   :       :      :
        :Th :Tne:                               :Tf :Tbb:Th:Tne:
 ____       :   :___:___________________________________:      :_____________
 DATA   ________|   :|__||__||__||__||__||__||__||__|   |______|
        :   :   : 0   1   2   3   4   5   6   7     :
        :   :   :LSB                         MSB    :
        :   :   :                   :
        :   :   : TALKER SENDING        Listener: Data Accepted
        :   : LISTENER READY-FOR-DATA
        : TALKER READY-TO-SEND



  Serial Bus Timing


    Description         Symbol   Min     Typ     Max

    ATN Response (required) 1)   Tat      -   - 1000us
    Listener Hold-Off        Th   0   -  oo
    Non-EOI Response to RFD 2)   Tne      -  40us   200us
    Bit Set-Up Talker  4)        Ts  20us    70us     -
    Data Valid           Tv  20us    20us     -
    Frame Handshake  3)      Tf   0   20    1000us
    Frame to Release of ATN      Tr  20us     -   -
    Between Bytes Time       Tbb    100us     -   -
    EOI Response Time        Tye    200us   250us     -
    EOI Response Hold Time  5)   Tei     60us     -   -
    Talker Response Limit        Try      0  30us    60us
    Byte-Acknowledge  4)         Tpr     20us    30us     -
    Talk-Attention Release       Ttk     20us    30us   100us
    Talk-Attention Acknowledge   Tdc      0   -   -
    Talk-Attention Ack. Hold     Tda     80us     -   -
    EOI Acknowledge          Tfr     60us     -   -


   Notes:
    1)  If maximum time exceeded, device not present error.
    2)  If maximum time exceeded, EOI response required.
    3)  If maximum time exceeded, frame error.
    4)  Tv and Tpr minimum must be 60us for external device to be a talker.
    5)  Tei minimum must be 80us for external device to be a listener.
*/

#include "cbmiec.h"
#include "machine/devhelpr.h"



//**************************************************************************
//  MACROS / CONSTANTS
//**************************************************************************

#define LOG 1


static const char *const SIGNAL_NAME[] = { "SRQ", "ATN", "CLK", "DATA", "RESET" };



//**************************************************************************
//  DEVICE DEFINITIONS
//**************************************************************************

const device_type CBM_IEC = cbm_iec_device_config::static_alloc_device_config;



//**************************************************************************
//  DEVICE CONFIGURATION INTERFACE
//**************************************************************************

//-------------------------------------------------
//  device_config_cbm_iec_interface - constructor
//-------------------------------------------------

device_config_cbm_iec_interface::device_config_cbm_iec_interface(const machine_config &mconfig, device_config &devconfig)
	: device_config_interface(mconfig, devconfig)
{
}


//-------------------------------------------------
//  ~device_config_cbm_iec_interface - destructor
//-------------------------------------------------

device_config_cbm_iec_interface::~device_config_cbm_iec_interface()
{
}



//**************************************************************************
//  DEVICE INTERFACE
//**************************************************************************

//-------------------------------------------------
//  device_cbm_iec_interface - constructor
//-------------------------------------------------

device_cbm_iec_interface::device_cbm_iec_interface(running_machine &machine, const device_config &config, device_t &device)
	: device_interface(machine, config, device),
	  m_cbm_iec_config(dynamic_cast<const device_config_cbm_iec_interface &>(config))
{
}


//-------------------------------------------------
//  ~device_cbm_iec_interface - destructor
//-------------------------------------------------

device_cbm_iec_interface::~device_cbm_iec_interface()
{
}



//**************************************************************************
//  DEVICE CONFIGURATION
//**************************************************************************

GENERIC_DEVICE_CONFIG_SETUP(cbm_iec, "CBM IEC")


//-------------------------------------------------
//  device_config_complete - perform any
//  operations now that the configuration is
//  complete
//-------------------------------------------------

void cbm_iec_device_config::device_config_complete()
{
	// inherit a copy of the static data
	const cbm_iec_config *intf = reinterpret_cast<const cbm_iec_config *>(static_config());
	if (intf != NULL)
		*static_cast<cbm_iec_config *>(this) = *intf;

	// or initialize to defaults if none provided
	else
	{
		fatalerror("Daisy chain not provided!");
	}

	m_daisy = intf;
}



//**************************************************************************
//  INLINE HELPERS
//**************************************************************************

//-------------------------------------------------
//  set_signal - 
//-------------------------------------------------

inline void cbm_iec_device::set_signal(device_t *device, int signal, int state)
{
	bool changed = false;

	for (daisy_entry *daisy = m_daisy_list; daisy != NULL; daisy = daisy->m_next)
	{
		if (!strcmp(daisy->m_device->tag(), device->tag()))
		{
			if (daisy->m_line[signal] != state)
			{
				if (LOG) logerror("CBM IEC: '%s' %s %u\n", device->tag(), SIGNAL_NAME[signal], state);
				daisy->m_line[signal] = state;
				changed = true;
			}
		}
	}

	if (changed)
	{
		for (daisy_entry *daisy = m_daisy_list; daisy != NULL; daisy = daisy->m_next)
		{
			switch (signal)
			{
			case SRQ:
				daisy->m_interface->cbm_iec_srq(state);
				break;

			case ATN:
				daisy->m_interface->cbm_iec_atn(state);
				break;

			case CLK:
				daisy->m_interface->cbm_iec_clk(state);
				break;

			case DATA:
				daisy->m_interface->cbm_iec_data(state);
				break;

			case RESET:
				daisy->m_interface->cbm_iec_reset(state);
				break;
			}
		}

		if (LOG) logerror("CBM IEC: SRQ %u ATN %u CLK %u DATA %u RESET %u\n", get_signal(SRQ),get_signal(ATN),get_signal(CLK),get_signal(DATA),get_signal(RESET));
	}
}


//-------------------------------------------------
//  get_signal - 
//-------------------------------------------------

inline int cbm_iec_device::get_signal(int signal)
{
	int state = 1;

	for (daisy_entry *daisy = m_daisy_list; daisy != NULL; daisy = daisy->m_next)
	{
		if (!daisy->m_line[signal])
		{
			state = 0;
			break;
		}
	}

	return state;
}



//**************************************************************************
//  LIVE DEVICE
//**************************************************************************

//-------------------------------------------------
//  cbm_iec_device - constructor
//-------------------------------------------------

cbm_iec_device::cbm_iec_device(running_machine &_machine, const cbm_iec_device_config &_config)
    : device_t(_machine, _config),
	  m_stub(*this->owner(), CBM_IEC_STUB_TAG),
      m_config(_config)
{
}


//-------------------------------------------------
//  device_start - device-specific startup
//-------------------------------------------------

void cbm_iec_device::device_start()
{
	const cbm_iec_config *daisy = m_config.m_daisy;

	// create a linked list of devices
	daisy_entry **tailptr = &m_daisy_list;
	for ( ; daisy->m_tag != NULL; daisy++)
	{
		// find the device
		device_t *target = machine().device(daisy->m_tag);
		if (target == NULL)
			fatalerror("Unable to locate device '%s'", daisy->m_tag);

		// make sure it has an interface
		device_cbm_iec_interface *intf;
		if (!target->interface(intf))
			fatalerror("Device '%s' does not implement the CBM IEC interface!", daisy->m_tag);

		// append to the end
		*tailptr = auto_alloc(machine(), daisy_entry(target));
		tailptr = &(*tailptr)->m_next;
	}

	// append driver stub to the end
	device_t *target = machine().device(CBM_IEC_STUB_TAG);
	*tailptr = auto_alloc(machine(), daisy_entry(target));
	tailptr = &(*tailptr)->m_next;
}


//-------------------------------------------------
//  daisy_entry - constructor
//-------------------------------------------------

cbm_iec_device::daisy_entry::daisy_entry(device_t *device)
	: m_next(NULL),
	  m_device(device),
	  m_interface(NULL)
{
	for (int i = 0; i < SIGNAL_COUNT; i++)
	{
		m_line[i] = 1;
	}

	device->interface(m_interface);
}


//-------------------------------------------------
//  srq_r -
//-------------------------------------------------

READ_LINE_MEMBER( cbm_iec_device::srq_r )
{
	return get_signal(SRQ);
}


//-------------------------------------------------
//  atn_r -
//-------------------------------------------------

READ_LINE_MEMBER( cbm_iec_device::atn_r )
{
	return get_signal(ATN);
}


//-------------------------------------------------
//  clk_r -
//-------------------------------------------------

READ_LINE_MEMBER( cbm_iec_device::clk_r )
{
	return get_signal(CLK);
}


//-------------------------------------------------
//  data_r -
//-------------------------------------------------

READ_LINE_MEMBER( cbm_iec_device::data_r )
{
	return get_signal(DATA);
}


//-------------------------------------------------
//  reset_r -
//-------------------------------------------------

READ_LINE_MEMBER( cbm_iec_device::reset_r )
{
	return get_signal(RESET);
}


//-------------------------------------------------
//  srq_w -
//-------------------------------------------------

WRITE_LINE_MEMBER( cbm_iec_device::srq_w )
{
	set_signal(m_stub, SRQ, state);
}


//-------------------------------------------------
//  atn_w -
//-------------------------------------------------

WRITE_LINE_MEMBER( cbm_iec_device::atn_w )
{
	set_signal(m_stub, ATN, state);
}


//-------------------------------------------------
//  clk_w -
//-------------------------------------------------

WRITE_LINE_MEMBER( cbm_iec_device::clk_w )
{
	set_signal(m_stub, CLK, state);
}


//-------------------------------------------------
//  data_w -
//-------------------------------------------------

WRITE_LINE_MEMBER( cbm_iec_device::data_w )
{
	set_signal(m_stub, DATA, state);
}


//-------------------------------------------------
//  reset_w -
//-------------------------------------------------

WRITE_LINE_MEMBER( cbm_iec_device::reset_w )
{
	set_signal(m_stub, RESET, state);
}


//-------------------------------------------------
//  srq_w -
//-------------------------------------------------

void cbm_iec_device::srq_w(device_t *device, int state)
{
	set_signal(device, SRQ, state);
}


//-------------------------------------------------
//  atn_w -
//-------------------------------------------------

void cbm_iec_device::atn_w(device_t *device, int state)
{
	set_signal(device, ATN, state);
}


//-------------------------------------------------
//  clk_w -
//-------------------------------------------------

void cbm_iec_device::clk_w(device_t *device, int state)
{
	set_signal(device, CLK, state);
}


//-------------------------------------------------
//  data_w -
//-------------------------------------------------

void cbm_iec_device::data_w(device_t *device, int state)
{
	set_signal(device, DATA, state);
}


//-------------------------------------------------
//  reset_w -
//-------------------------------------------------

void cbm_iec_device::reset_w(device_t *device, int state)
{
	set_signal(device, RESET, state);
}
